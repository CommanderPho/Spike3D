---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## PROJECT OVERVIEW

This document defines the rules, coding standards, workflow guidelines, references, documentation structures, and best practices for this project. It serves as a living document that evolves with the project.

## CODE STYLE

*   Follow PEP 8 guidelines for Python code.
*   Use descriptive variable and function names.
*   Keep functions short and focused.
*   Add comments to explain complex logic.
*   There must be two blank lines between Python class methods.

## FOLDER ORGANIZATION

*   Project root: Contains core files, configuration, and documentation.
*   `src`: Source code.
*   `tests`: Unit and integration tests.
*   `data`: Data files (e.g., datasets, models).
*   `docs`: Project documentation.

## TECH STACK

*   Python 3.x
*   NumPy
*   Vispy
*   Pandas

## PROJECT-SPECIFIC STANDARDS

*   When working with Vispy, prioritize modularity and decoupling of components.
*   The `render_contours` method in `@pyphoplacecellanalysis/Pho2D/vispy/vispy_helpers.py` must not be coupled to `self` or any of the views. It should be able to take a list of binary numpy arrays (2D masks) and render the contours with a specified color or color mapping. The refactored `render_contours` method should accept explicit arguments: `masks`, `x_bounds`, `y_bounds`, `color`/`colors`/`cmap`, and optionally `parents` (sequence of `vispy.scene.Node`).
    *   It should use the helper functions `contours_from_masks` and `create_contour_line_visuals` defined in the same file.
    *   Add support for filling in the contour line with a translucent fill that defaults to the same color as the contour line in `@pyphoplacecellanalysis/Pho2D/vispy/vispy_helpers.py:155-292`.
        *   The `create_contour_line_visuals` function should return a tuple of `(lines, polygons)` so polygons can be cleared. The call sites should extend the contour lists with both polygons and lines.
*   When creating Vispy line visuals, the `heading_angle_to_rainbow_rgba(angle_deg, alpha=1.0)` and `heading_angles_to_rainbow_colors(heading_angles_deg, alpha=1.0)` functions in `@pyphoplacecellanalysis/Pho2D/vispy/vispy_helpers.py` should be used to map the `heading` (0-360°) to RGB using HSV with 0°=red, 60°=yellow, 120°=green, 240°=blue, and 300°=violet. Ensure to use the function `create_heading_rainbow_line(pos, parent=None, headings_deg=None, line_width=2.0, order=10, alpha=1.0, method='gl')` to build the Vispy Line with per-vertex colors from heading. If `headings_deg` is `None`, headings are computed from `pos`.
*   In `@pyphoplacecellanalysis/Pho2D/vispy/position_heading_angle.py`, when drawing the Compass Rose (CompassDemo), the off-cardinal (NE, SW, etc) lines must be half the length as the cardinal lines (N, E, ...).
*   In `@pyphoplacecellanalysis/Pho2D/vispy/position_heading_angle.py`, when drawing the Compass Rose (CompassDemo), a thick circle centered at `center` must be added to `CompassLegendItem`.
    *   A `scene.visuals.Ellipse` is created at `center` with:
        *   **Radius**: `circle_radius` (default `length * 0.08`) so it stays small relative to the compass.
        *   **Outline only**: `color=None`, `border_width=circle_border_width` (default `2.0`), `border_color=circle_color` (default white).
        *   Same parent and GL state as the line: `parent=view.scene`, `set_gl_state('translucent', depth_test=False)`.
    *   New constructor options (all optional):
        *   `circle_radius` – circle radius (default `length * 0.08`).
        *   `circle_border_width` – outline thickness (default `2.0`).
        *   `circle_color` – outline color (default `(1.0, 1.0, 1.0, 1.0)`).
*   **Vispy Examples Browser Implementation:**
    *   `vispy_EXAMPLES.py` is implemented in the same way as `Silx_EXAMPLES.py` (and in the same spirit as the PyQtPlot examples entry point):
        1.  **Same structure**
            *   Sets `PYQTGRAPH_QT_LIB='PyQt5'` before any Qt use.
            *   `PythonSyntaxHighlighter` for the code preview (same rules as Silx).
            *   A main window browser class (`VispyExampleBrowser`) with:
                *   Left: list of examples and a “Run Example” button.
                *   Right: description and read-only source code with syntax highlighting.
            *   Examples scanned from a directory, descriptions from module docstrings, and “Run Example” launches the selected script in a subprocess (e.g. new console on Windows).

                *   Right-clicking an example to add it as a favorite is enabled. Favorites are rendered in the list with an "(*) " to the left of their title string.

        2.  **Vispy-specific adjustments**
            *   Uses **PyQt5** directly (`PyQt5.QtWidgets`, `PyQt5.QtGui`, `PyQt5.QtCore`) so the vispy launcher does not depend on `silx.gui.qt`.
            *   Examples directory is **`examples/`** next to `vispy_EXAMPLES.py` (i.e. `LibrariesExamples/vispy/examples/`).
            *   **Recursive scan** with `examples_dir.rglob("*.py")` so all nested `.py` files (e.g. `basics/visuals/arrows_quiver.py`, `pho_custom/colored_line_advnaced.py`) are listed; display name is the relative path with slashes (e.g. `basics/visuals/arrows_quiver`).
            *   `__init__.py` files are skipped.
            *   Window title is **“Vispy Examples Browser”**.
            *   The Vispy window launched shows the example name as its title.

        3.  **PyQtPlot similarity**
            *   Same idea as PyQtPlot_EXAMPLES: a single entry point that brings up the examples UI (here, the library’s `examples.run()`).
    *   Run it with: `python LibrariesExamples/vispy/vispy_EXAMPLES.py` or from the repo root: `uv run python LibrariesExamples/vispy/vispy_EXAMPLES.py`
*   **Vispy Subplot Grids:**
    *   When implementing vispy plotting examples with subplots, particularly in `plot_grids.py`, the following approach should be used:
        *   Define `n_fixed_columns: int = 6` to specify the number of columns in the grid.
        *   Compute the number of rows (`n_rows: int`) dynamically based on the total number of plots needed to be rendered.
        *   Use `vispy.plot.Fig` to create a figure window. Subplots are created on demand by indexing like `fig[row, col]`.
        *   To reduce padding between subplots, set the `spacing` attribute of the internal grid after the `Fig` is created. For example: `fig._grid.spacing = 0`
        *   Example implementation:
            ```python
            def make_grid_figure(n_plots: int, n_fixed_columns: int = 6, fig_size=(900, 600), show=False):
                """Create a vispy Fig with a grid of subplots: n_fixed_columns columns and n_rows rows."""
                n_rows = max(1, math.ceil(n_plots / n_fixed_columns))
                fig = vp.Fig(size=fig_size, show=show)
                fig._grid.spacing = 0 # minimize padding
                return fig, n_rows, n_fixed_columns
            ```
*   Implement a Matplotlib version of the heading-angle shaded trajectory line (working using Vispy here: `@pyphoplacecellanalysis/Pho2D/vispy/vispy_helpers.py:370-397`) in `@pyphoplacecellanalysis/PhoPositionalData/plotting/mixins/decoder_plotting_mixins.py:2264-2301`. The Matplotlib version should color the line by heading angle (0°=red through ROYGBIV to 359°=violet), similar to the Vispy implementation.
*   All methods in `@pyphocorehelpers/plotting/heading_angle_helpers.py` must be classmethods of the `HeadingAngleHelpers` class.
*   In `@pyphoplacecellanalysis/PhoPositionalData/plotting/mixins/decoder_plotting_mixins.py:2327-2386`, when adding concentrated arrows to a line, enable modes to determine arrow colors using the `RenderColoringMode` Enum:
    *   `RenderColoringMode.SPEED`: colors by speed via `time_cmap`.
    *   `RenderColoringMode.ANGLE`: colors by direction via `HeadingAngleHelpers` (North=Red, ROYGBIV).
    *   `RenderColoringMode.TIME`: Colors the arrows by time.

*   In `@pyphoplacecellanalysis/PhoPositionalData/plotting/mixins/decoder_plotting_mixins.py:2233-2274`, the `_helper_add_gradient_line` function should support `RenderColoringMode`:
    *   `RenderColoringMode.TIME` (or SPEED): current behavior (time colormap on segments).
    *   `RenderColoringMode.ANGLE`: use the logic from `_helper_add_gradient_angle_visualizing_line` (heading-colored segments and markers).
*   **Matplotlib Plot Titles:** When adding titles to matplotlib plots using `ax.set_title()`, use `loc='left'` for left alignment. The default alignment is `loc='center'`. Options are 'left', 'center', 'right'.
*   **Datoviz Examples Browser Implementation:** Implement an interactive datoviz example browser analagous to the existing example browsers for Vispy (`vispy_EXAMPLES.py`), PyQtPlot (`PyQtPlot_EXAMPLES.py`), and Silx (`Silx_EXAMPLES.py`). The new datoviz browser should be located in the `@datoviz` folder.
    *   The `datoviz_EXAMPLES.py` is to be located in `LibrariesExamples/datoviz/`. It will be modeled on `vispy_EXAMPLES.py` (full-featured with PyQt5, syntax highlighter, favorites, recursive scan of examples/).
    *   Examples directory: `current_file.parent / "examples"` (recursive `rglob("*.py")`), skip `__init__.py`. This includes `quickstart`, `features/*`, `showcase/*`, `visuals/*`, and `benchmarks/benchmark_mpl.py`.
    *   Run: `subprocess.Popen([sys.executable, script_path], creationflags=CREATE_NEW_CONSOLE on Windows)`—no wrapper script needed for datoviz.
*   **Vispy Trajectory Segments Visual:**
    *   Implement a new highly efficient vispy visual that takes a `List[pd.DataFrame]` indicating segments of a 2D position trajectory, and it renders them on a single canvas while allowing the user to specify how each are drawn. It should be in the form of a single usable class or a single function.
    *   **Efficiency Options:**
        *   **Single Line + connect array**: Concatenate all segment positions; build an (M, 2) connect array that links only consecutive vertices within each segment (no link across segment boundaries). One draw call, one Line. Supports per-vertex color (so per-segment color = same color for all vertices of that segment). Width must be uniform for the whole Line.
        *   **N Line visuals under one parent**: One Line per segment; each can have its own width, color, method. N draw calls but full per-segment control. This is what `create_contour_line_visuals` does.
    *   For "highly efficient" + "user specify how each are drawn", the best design is:
        *   **Primary path (efficient)**: When all segments share the same line width (and optionally same method), use one Line with connect array + vertex colors (per-segment color = repeat color for each vertex in that segment). Single draw call, minimal state.
        *   **Fallback**: When segments need different widths (or different methods), use one Line per segment under a single parent Node; still "one canvas" from the user's perspective (one parent to add to the view).
    *   The class should be something like: `TrajectorySegmentsVisual(parent, segments: List[pd.DataFrame], ...)`
    *   Segment style: either a single style dict (color, width, method) applied to all, or a list of dicts / a callable `(idx, df) -> dict` for per-segment color/width/method.
    *   Internally: if all widths (and methods) are the same, build one Line with connect + vertex colors; else build N Lines.
    *   **DataFrame column handling:** Allow `x_col='x', y_col='y'` (default). Extract positions as `np.column_stack([df[x_col].values, df[y_col].values]).astype(np.float32)`.

## WORKFLOW & RELEASE RULES

*   Use Git for version control.
*   Create pull requests for all code changes.
*   All pull requests must be reviewed before merging.
*   Follow semantic versioning for releases.

## REFERENCE EXAMPLES

(This section is currently empty, but will be populated with code examples as the project evolves.)

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   Use docstrings to document all functions and classes.
*   Maintain up-to-date README files in each directory.
*   Use a consistent documentation style.

## DEBUGGING

*   Use a debugger to step through code and inspect variables.
*   Write unit tests to catch errors early.
*   Use logging to track down issues in production.
*   When encountering Vispy shader compilation errors, carefully examine the shader code for syntax errors, especially unexpected end-of-file (EOF) tokens. If the driver continues to receive empty shader source, consider refactoring the demos to use `vispy.scene.SceneCanvas` and `vispy.scene.visuals.Line` with precomputed per-vertex colors.

## FINAL DOs AND DON'Ts

*   **DO** write clean, readable code.
*   **DO** follow the established coding standards.
*   **DO** write unit tests for all code.
*   **DON'T** commit code without review.
*   **DON'T** introduce unnecessary complexity.