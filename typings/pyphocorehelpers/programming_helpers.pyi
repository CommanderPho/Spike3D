"""
This type stub file was generated by pyright.
"""

import contextlib
import pandas as pd
import ast
from pathlib import Path
from typing import Callable, Dict, List, Optional, Tuple, Union
from enum import Enum, unique
from attrs import define
from pyphocorehelpers.DataStructure.enum_helpers import ExtendedEnum
from pyphocorehelpers.function_helpers import function_attributes

def documentation_tags(func, *tags): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """Adds documentations tags to a function or class

    Usage:
        from pyphocorehelpers.programming_helpers import documentation_tags
        @documentation_tags('tag1', 'tag2')
        def my_function():
            ...

        Access via:
            my_function.tags

    """
    ...

_custom_metadata_attribute_names = ...
def metadata_attributes(short_name=..., tags=..., creation_date=..., input_requires=..., output_provides=..., uses=..., used_by=..., related_items=..., pyqt_signals_emitted=...): # -> Callable[..., Any]:
    """Adds generic metadata attributes to a function or class
    Aims to generalize `pyphocorehelpers.function_helpers.function_attributes`

    ```python
        from pyphocorehelpers.programming_helpers import metadata_attributes

        @metadata_attributes(short_name='pf_dt_sequential_surprise', tags=['tag1','tag2'], input_requires=[], output_provides=[], uses=[], used_by=[])
        def _perform_time_dependent_pf_sequential_surprise_computation(computation_result, debug_print=False):
            # function body
    ```

    func.short_name, func.tags, func.creation_date, func.input_requires, func.output_provides, func.uses, func.used_by
    """
    ...

def build_metadata_property_reverse_search_map(a_fn_dict, a_metadata_property_name=...): # -> dict[Any | None, Any]:
    """allows lookup of key into the original dict via a specific value of a specified property
    Usage:
        from pyphocorehelpers.programming_helpers import build_metadata_property_reverse_search_map
        short_name_reverse_lookup_map = build_metadata_property_reverse_search_map(curr_active_pipeline.registered_merged_computation_function_dict, a_metadata_property_name='short_name')
        short_name_search_value = 'long_short_fr_indicies_analyses'
        short_name_reverse_lookup_map[short_name_search_value] # '_perform_long_short_firing_rate_analyses'
    """
    ...

def build_fn_properties_dict(a_fn_dict, included_attribute_names_list: Optional[List] = ..., private_attribute_names_list: List[str] = ..., debug_print: bool = ...) -> Dict:
    """ Given a dictionary of functions tries to extract the metadata

    from pyphocorehelpers.programming_helpers import build_fn_properties_dict

    Example: Merged Functions:
        computation_fn_dict = curr_active_pipeline.registered_merged_computation_function_dict
        computation_fn_metadata_dict = build_fn_properties_dict(curr_active_pipeline.registered_merged_computation_function_dict, ['__name__', 'short_name'], private_attribute_names_list=[])
        computation_fn_metadata_dict
    """
    ...

def build_fn_properties_df(a_fn_dict, included_attribute_names_list: Optional[List] = ..., private_attribute_names_list: List[str] = ..., debug_print: bool = ...) -> pd.DataFrame:
    """ Given a dictionary of functions tries to extract the metadata

    from pyphocorehelpers.programming_helpers import build_fn_properties_df

    Usage Examples:
        display_fn_dict = curr_active_pipeline.registered_display_function_dict
        display_fn_df = build_fn_properties_df(display_fn_dict)
        display_fn_df

    Example 2: Global Computation Functions
        global_computation_fn_dict = curr_active_pipeline.registered_global_computation_function_dict
        global_computation_fn_df = build_fn_properties_df(global_computation_fn_dict)
        global_computation_fn_df

    Example 3: Merged Functions:
        computation_fn_dict = curr_active_pipeline.registered_merged_computation_function_dict
        computation_fn_df = build_fn_properties_df(computation_fn_dict)
        computation_fn_df
    """
    ...

def copy_to_clipboard(code_str: str, message_print=...): # -> None:
    """ tries a clean method that uses the jaraco.clipboard library, but falls back to Pandas for compatibility if it isn't available
    """
    ...

def copy_image_to_clipboard(image, message_print=...): # -> None:
    """ copies the passed image to the system clipboard. Only works on Windows.
    
    from PIL import Image
    from pyphocorehelpers.programming_helpers import copy_image_to_clipboard
    
     
    
    from pyphocorehelpers.programming_helpers import copy_image_to_clipboard

    canvas = self.ui.canvas

    canvas.draw()  # Ensure the canvas has been drawn once before copying the figure        
    buf = io.BytesIO()
    canvas.print_png(buf)
    buf.seek(0)
    img = Image.open(buf)
    # Send the image to the clipboard
    copy_image_to_clipboard(img)
    buf.close()
        
     """
    ...

class CodeParsers:
    """

    from pyphocorehelpers.programming_helpers import CodeParsers

    print(extract_variable_names(CodeParsers.code_block))
    """
    @classmethod
    def extract_imported_names(cls, code): # -> set[Any]:
        ...
    
    @classmethod
    def extract_assigned_variable_names(cls, code: str) -> List[str]:
        """
        Extracts the names of all assigned variables from the given code block.

        Args:
        code (str): A string containing the Python code from which to extract variable names.

        Returns:
        list: A list of variable names assigned in the code.

        Usage:
            # # Example usage
            # print(extract_variable_names(code_block))

        """
        ...
    
    @classmethod
    def extract_referenced_names(cls, code: str) -> List[str]:
        ...
    
    @classmethod
    def find_input_variables(cls, code: str): # -> list[str]:
        ...
    
    @classmethod
    def convert_to_kwarg_passthrough(cls, input_str, post_equals_space: bool = ..., to_clipboard=...): # -> LiteralString:
        """
        Convert a string of parameters into a keyword argument passthrough format.

        Prompt:

        Write a python function that given a string like 'single_plot_fixed_height=100.0, debug_test_max_num_slices=20, size=(15,15), dpi=72, constrained_layout=True, scrollable_figure=True' it should produce a string like 'single_plot_fixed_height=single_plot_fixed_height, debug_test_max_num_slices=debug_test_max_num_slices, size=size, dpi=dpi, constrained_layout=constrained_layout, scrollable_figure=scrollable_figure'

        Args:
            input_str (str): Input string containing parameters.

        Returns:
            str: Formatted string with parameters as keyword arguments.

        Usage:

        CodeParsers.convert_to_kwarg_passthrough( 'single_plot_fixed_height=100.0, debug_test_max_num_slices=20, size=(15,15), dpi=72, constrained_layout=True, scrollable_figure=True')
        >>> 'single_plot_fixed_height=single_plot_fixed_height, debug_test_max_num_slices=debug_test_max_num_slices, size=size, dpi=dpi, constrained_layout=constrained_layout, scrollable_figure=scrollable_figure'

        """
        ...
    


class IPythonHelpers:
    """ various helpers useful in jupyter-lab notebooks and IPython

    import IPython
    from pyphocorehelpers.programming_helpers import IPythonHelpers
    notebook_name = IPythonHelpers.try_find_notebook_filepath(IPython.extract_module_locals())


    Future Explorations:
        from ipywidgets import get_ipython # required for IPythonHelpers.cell_vars
        import io
        from contextlib import redirect_stdout

        ipy = get_ipython()
        ipy

        ipy.config
        {'IPKernelApp': {'ip': '127.0.0.1',
        'stdin_port': 9018,
        'control_port': 9016,
        'hb_port': 9015,
        'shell_port': 9017,
        'transport': 'tcp',
        'iopub_port': 9019,
        'connection_file': '/home/halechr/.local/share/jupyter/runtime/kernel-v2-11469ce5F9Z6kztRl.json'},
        'Session': {'signature_scheme': 'hmac-sha256',
        'key': b'e8f1060a-87a5-4060-9275-77318885dab6'},
        'Completer': {'use_jedi': False},
        'IPCompleter': {'use_jedi': False}}

        # ipy.find_user_code
        # ipy.get_local_scope
        # ipy.inspector.class_get_help
        # ipy.get_ipython()

    """
    @classmethod
    def try_find_notebook_filepath(cls, module_locals=...) -> Optional[str]:
        """ tries multiple methods to get a Jupyter notebok's filepath
        Usage:
            MUST be called like:
            import IPython
            from pyphocorehelpers.programming_helpers import IPythonHelpers
            notebook_name = IPythonHelpers.try_find_notebook_filepath(IPython.extract_module_locals())

        """
        ...
    
    @classmethod
    def cell_vars(cls, get_globals_fn=..., offset=...): # -> dict[str, Any]:
        """ Captures a dictionary containing all assigned variables from the notebook cell it's used in.

        NOTE: You MUST call it with `captured_cell_vars = IPythonHelpers.cell_vars(lambda: globals())` if you want to access it in a notebook cell.

        Arguments:
            get_globals_fn: Callable - required for use in a Jupyter Notebook to access the correct globals (see ISSUE 2023-05-10


        Source:
            https://stackoverflow.com/questions/46824287/print-all-variables-defined-in-one-jupyter-cell
            BenedictWilkins
            answered Jun 12, 2020 at 15:55

        Usage:
            from pyphocorehelpers.programming_helpers import IPythonHelpers

            a = 1
            b = 2
            c = 3

            captured_cell_vars = IPythonHelpers.cell_vars(lambda: globals())

            >> {'a': 1, 'b': 2, 'c': 3}


        SOLVED ISSUE 2023-05-10 - Doesn't currently work when imported into the notebook because globals() accesses the code's calling context (this module) and not the notebook.
            See discussion here: https://stackoverflow.com/questions/61125218/python-calling-a-module-function-which-uses-globals-but-it-only-pulls-global
            https://stackoverflow.com/a/1095621/5646962

            Tangentially relevent:
                https://stackoverflow.com/questions/37718907/variable-explorer-in-jupyter-notebook

            Alternative approaches:
                https://stackoverflow.com/questions/27952428/programmatically-get-current-ipython-notebook-cell-output/27952661#27952661


        """
        ...
    
    @classmethod
    def extract_cells(cls, notebook_path: Union[Path, str]):
        """ extracts the cells from the provided notebook.
        # Example usage
        notebook_path = '../BatchGenerateOutputs_2023-11-13.ipynb'
        extracted_cells = IPythonHelpers.extract_cells(notebook_path)
        print(extracted_cells)

        cells_with_tags = []
        for cell in extracted_cells:
            cell_content = cell['source']
            cell_tags = cell['metadata'].get('tags', None)
            if (cell_tags is not None) and (len(cell_tags) > 0):
                cells_with_tags.append({'content': cell_content, 'tags': cell_tags})

        cells_with_tags
        """
        ...
    
    @classmethod
    def write_notebook(cls, cells, path: Path): # -> None:
        """ writes a new notebook with the provided cells to the path provided. """
        ...
    


@define(slots=False)
class NotebookProcessor:
    """ processes Jupyter Notebooks
    from pyphocorehelpers.programming_helpers import NotebookProcessor

    notebook_path = Path(r"C:/Users/pho/repos/Spike3DWorkEnv/Spike3D/ReviewOfWork_2024-01-22.ipynb").resolve()
    processor = NotebookProcessor(path=notebook_path)

    """
    path: Path = ...
    cells: List = ...
    def __attrs_post_init__(self): # -> None:
        ...
    
    def load_cells(self): # -> None:
        ...
    
    def get_cells_with_tags(self): # -> list[dict[str, Any]]:
        ...
    
    def get_cells_with_tag(self, tag): # -> list[dict[str, Any]]:
        ...
    
    def get_empty_cells(self): # -> list[Any]:
        ...
    
    def remove_empty_cells_and_save(self, new_path): # -> None:
        """
        ## Remove all empty cells, and save the resultant notebook as the current notebook with the '_cleaned' filename suffix (but same extention)
        new_path = processor.path.with_stem(f'{processor.path.stem}_cleaned').resolve()
        processor.remove_empty_cells_and_save(new_path=new_path)


        """
        ...
    


class PythonDictionaryDefinitionFormat(Enum):
    """Enumeration for Python dictionary definition formats.
    TODO 2023-05-16: UNTESTED, UNUSED
    Goal: Transform code between Python's dictionary literal format:

        dictionary literal format:  {'require_intersecting_epoch':session.ripple, 'min_epoch_included_duration': 0.06, 'max_epoch_included_duration': None, 'maximum_speed_thresh': None, 'min_inclusion_fr_active_thresh': 0.01, 'min_num_unique_aclu_inclusions': 3}

        dict constructor format:    dict(require_intersecting_epoch=session.ripple, min_epoch_included_duration=0.06, max_epoch_included_duration=None, maximum_speed_thresh=None, min_inclusion_fr_active_thresh=0.01, min_num_unique_aclu_inclusions=3)


        from pyphocorehelpers.programming_helpers import PythonDictionaryDefinitionFormat
        input_str = "{'require_intersecting_epoch':session.ripple, 'min_epoch_included_duration': 0.06, 'max_epoch_included_duration': None, 'maximum_speed_thresh': None, 'min_inclusion_fr_active_thresh': 0.01, 'min_num_unique_aclu_inclusions': 3}"
        format_detected = PythonDictionaryDefinitionFormat.DICTIONARY_LITERAL

        converted_str = PythonDictionaryDefinitionFormat.convert_format(input_str, PythonDictionaryDefinitionFormat.DICT_CONSTRUCTOR)
        print(converted_str)
        # Output: dict(require_intersecting_epoch=session.ripple, min_epoch_included_duration=0.06, max_epoch_included_duration=None, maximum_speed_thresh=None, min_inclusion_fr_active_thresh=0.01, min_num_unique_aclu_inclusions=3)

    """
    DICTIONARY_LITERAL = ...
    DICT_CONSTRUCTOR = ...
    @staticmethod
    def convert_format(input_str, target_format): # -> str:
        """Converts the input string to the target format."""
        ...
    


@contextlib.contextmanager
def disable_function_context(obj, fn_name: str): # -> Generator[None, Any, None]:
    """ Disables a function within a context manager

    https://stackoverflow.com/questions/10388411/possible-to-globally-replace-a-function-with-a-context-manager-in-python

    Could be used for plt.show().
    ```python

    from pyphocorehelpers.programming_helpers import override_function_context

    with disable_function_context(plt, "show"):
        run_me(x)

    """
    ...

@contextlib.contextmanager
def override_function_context(obj, fn_name: str, override_defn): # -> Generator[None, Any, None]:
    """ Overrides a function's definition with a different one within a context manager

    https://stackoverflow.com/questions/10388411/possible-to-globally-replace-a-function-with-a-context-manager-in-python

    Could be used for plt.show().
    ```python

    from pyphocorehelpers.programming_helpers import override_function_context

    with override_function_context(plt, "show", custom_print):
        run_me(x)

    """
    ...

class MemoryManagement:
    """
    from pyphocorehelpers.programming_helpers import MemoryManagement

    args = MemoryManagement.deduplicate_memory_references(args)


    """
    @classmethod
    def print_memory_references(cls, *args) -> bool:
        """Check for duplicated memory references in the configs first

        from pyphocorehelpers.programming_helpers import MemoryManagement


        MemoryManagement.print_memory_references()


        """
        ...
    
    @classmethod
    def has_duplicated_memory_references(cls, *args) -> bool:
        """Check for duplicated memory references in the configs first

        from pyphocorehelpers.programming_helpers import MemoryManagement


        MemoryManagement.has_duplicated_memory_references()


        """
        ...
    
    @classmethod
    def deduplicate_memory_references(cls, *args) -> list:
        """ Ensures that all entries in the args list point to unique memory addresses, deduplicating them with `deepcopy` if needed.

        Usage:

            from pyphocorehelpers.programming_helpers import MemoryManagement

            args = MemoryManagement.deduplicate_memory_references(args)

        """
        ...
    


FunctionInspectionTuple = ...
def inspect_callable_arguments(a_callable: Callable, debug_print=...) -> FunctionInspectionTuple:
    """ Inspects a callable's arguments

    Usage:        
        from pyphocorehelpers.programming_helpers import inspect_callable_arguments, FunctionInspectionTuple

        fn_inspect_tuple: FunctionInspectionTuple = inspect_callable_arguments(PhoPaginatedMultiDecoderDecodedEpochsWindow.init_from_track_templates)
        fn_inspect_tuple

        # FunctionInspectionTuple(full_fn_spec=FullArgSpec(args=['cls', 'curr_active_pipeline', 'track_templates', 'decoder_decoded_epochs_result_dict', 'epochs_name', 'included_epoch_indicies', 'name', 'title', 'defer_show'], varargs=None, varkw='kwargs',
        #                                                   defaults=('laps', None, 'CombinedDirectionalDecoderDecodedEpochsWindow', 'Pho Combined Directional Decoder Decoded Epochs', False), kwonlyargs=[], kwonlydefaults=None, annotations={'epochs_name': <class 'str'>}),
        #                         positional_args_names=['cls', 'curr_active_pipeline', 'track_templates', 'decoder_decoded_epochs_result_dict'],
        #                         kwargs_names=['epochs_name', 'included_epoch_indicies', 'name', 'title', 'defer_show'],
        #                         default_kwargs_dict={'epochs_name': 'laps', 'included_epoch_indicies': None, 'name': 'CombinedDirectionalDecoderDecodedEpochsWindow', 'title': 'Pho Combined Directional Decoder Decoded Epochs', 'defer_show': False})
                


    Progress:
        import inspect
        from neuropy.plotting.ratemaps import plot_ratemap_1D, plot_ratemap_2D
        from pyphocorehelpers.programming_helpers import inspect_callable_arguments
        
        fn_spec = inspect.getfullargspec(plot_ratemap_2D)
        fn_sig = inspect.signature(plot_ratemap_2D)
        ?fn_sig

            # fn_sig
        dict(fn_sig.parameters)
        # fn_sig.parameters.values()

        fn_sig.parameters['plot_mode']
        # fn_sig.parameters
        fn_spec.args # all kwarg arguments: ['x', 'y', 'num_bins', 'debug_print']

        fn_spec.defaults[-2].__class__.__name__ # a tuple of default values corresponding to each argument in args; ((64, 64), False)
    """
    ...

def get_arguments_as_optional_dict(**kwargs): # -> None:
    """ Easily converts your existing argument-list style default values into a dict:
            Defines a simple function that takes only **kwargs as its inputs and prints the values it recieves. Paste your values as arguments to the function call. The dictionary will be output to the console, so you can easily copy and paste.
        Usage:
            >>> get_arguments_as_optional_dict(point_size=8, font_size=10, name='build_center_labels_test', shape_opacity=0.8, show_points=False)

            Output: ", **({'point_size': 8, 'font_size': 10, 'name': 'build_center_labels_test', 'shape_opacity': 0.8, 'show_points': False} | kwargs)"
    """
    ...

@unique
class GeneratedClassDefinitionType(ExtendedEnum):
    """Specifies which type of class to generate in CodeConversion.convert_dictionary_to_class_defn(...)."""
    STANDARD_CLASS = ...
    DATACLASS = ...
    ATTRS_CLASS = ...
    @property
    def class_decorators(self):
        ...
    
    @property
    def class_required_imports(self):
        ...
    
    @property
    def include_init_fcn(self):
        ...
    
    @property
    def include_properties_defns(self):
        ...
    
    @classmethod
    def decoratorsList(cls): # -> dict[Any, Any]:
        ...
    
    @classmethod
    def requiredImportsList(cls): # -> dict[Any, Any]:
        ...
    
    @classmethod
    def include_init_fcnList(cls): # -> dict[Any, Any]:
        ...
    
    @classmethod
    def include_properties_defnsList(cls): # -> dict[Any, Any]:
        ...
    


@metadata_attributes(short_name=None, tags=['source-code-parsing', 'source-code'], input_requires=[], output_provides=[], uses=[], used_by=[], creation_date='2024-03-07 08:37', related_items=[])
class SourceCodeParsing:
    """ Contains functions that help parse python source code.
    
    Can be used in the future to enable VSCode coding automations like converting selected text between two formats, etc.


    
    """
    @classmethod
    @function_attributes(short_name=None, tags=['return', 'source-code-parsing', 'pho'], input_requires=[], output_provides=[], uses=[], used_by=[], creation_date='2024-03-07 08:38', related_items=[])
    def get_return_line_numbers(cls, func): # -> list[int]:
        """ Get the line numbers in the source code of a function where a 'return' statement appears. 
        
        from pyphocorehelpers.programming_helpers import SourceCodeParsing

        return_lines_info = SourceCodeParsing.get_last_return_lines(compute_pho_heuristic_replay_scores)
        for line_no, code in return_lines_info:
            print(f"Line {line_no}: {code}")
            
        """
        ...
    
    @classmethod
    @function_attributes(short_name=None, tags=['ALT', 'source-code-parsing', 'pho', 'efficiency'], input_requires=[], output_provides=[], uses=[], used_by=[], creation_date='2024-03-07 08:36', related_items=[])
    def get_last_return_lines(cls, func): # -> list[tuple[Any, Any]]:
        """ Get the line and code of the last return statement of each block in a function. """
        class ReturnVisitor(ast.NodeVisitor):
            ...
        
        
    


class CodeConversion:
    """ Converts code (usually passed as text) to various alternative formats to ease development workflows.
    from pyphocorehelpers.programming_helpers import CodeConversion

    TODO 2023-10-24 - Add Ignored imports:
    ignored_imports = ['import bool,
        "import str",
        "import tuple",
        "import list",
        "import dict",
        ]

    substitution_dict = {'pathlib.WindowsPath':'pathlib.Path',
    'pathlib.PosixPath':'pathlib.Path'
    }


    # Definition Lines: __________________________________________________________________________________________________ #
    ## a multiline string containing lines of valid python code definitions
    test_parameters_defns_code_string = '''
                max_num_spikes_per_neuron = 20000 # the number of spikes to truncate each neuron's timeseries to
                kleinberg_parameters = DynamicParameters(s=2, gamma=0.1)
                use_progress_bar = False # whether to use a tqdm progress bar
                debug_print = False # whether to print debug-level progress using traditional print(...) statements
            '''
    ## Functions: `convert_defn_lines_to_dictionary(...)`, `convert_defn_lines_to_parameters_list(...)`, `convert_defn_lines_to_parameters_list(...)`,

    # Dictionary: ________________________________________________________________________________________________________ #
        {'spike_raster_plt_2d': <pyphoplacecellanalysis.GUI.PyQtPlot.Widgets.SpikeRasterWidgets.Spike2DRaster.Spike2DRaster at 0x168558703a0>,
                'spike_raster_plt_3d': <pyphoplacecellanalysis.GUI.PyQtPlot.Widgets.SpikeRasterWidgets.Spike3DRaster.Spike3DRaster at 0x1673e722310>,
                'spike_raster_window': <pyphoplacecellanalysis.GUI.Qt.SpikeRasterWindows.Spike3DRasterWindowWidget.Spike3DRasterWindowWidget at 0x1673e7aaa60>}



    """
    _types_replace_dict = ...
    _inverse_types_replace_dict = ...
    _general_find_replace_dict = ...
    @classmethod
    def apply_find_replace(cls, find_replace_dict: dict, target_str: str): # -> str:
        """ returns the target_str after applying each find/replace pair in find_replace_dict to it.

        Usage:

            cls.apply_find_replace(find_replace_dict=cls._general_find_replace_dict, target_str=)
        """
        ...
    
    @classmethod
    def split_type_str(cls, type_str): # -> tuple[str, Any]:
        """ for type_str = 'neuropy.core.epoch.Epoch' """
        ...
    
    @classmethod
    def get_import_statement_from_type_str(cls, type_str): # -> str:
        """ for type_str = 'neuropy.core.epoch.Epoch' """
        ...
    
    @classmethod
    def convert_dictionary_to_defn_lines(cls, target_dict, multiline_assignment_code=..., dictionary_name: str = ..., include_comment: bool = ..., copy_to_clipboard=..., output_variable_prefix=...): # -> str:
        """ The reciprocal operation of convert_defn_lines_to_dictionary
            target_dict: either a dictionary object or a string of code that defines a dictionary object (such as "{'firing_rate':curr_ax_firing_rate, 'lap_spikes': curr_ax_lap_spikes, 'placefield': curr_ax_placefield}")
            multiline_assignment_code: if True, generates a separate line for each assignment, otherwise assignment is done inline
            dictionary_name: the name to use for the dictionary in the generated code

        Examples:
            from pyphocorehelpers.general_helpers import CodeConversion
            curr_active_pipeline.last_added_display_output
            >>> {'spike_raster_plt_2d': <pyphoplacecellanalysis.GUI.PyQtPlot.Widgets.SpikeRasterWidgets.Spike2DRaster.Spike2DRaster at 0x168558703a0>,
                'spike_raster_plt_3d': <pyphoplacecellanalysis.GUI.PyQtPlot.Widgets.SpikeRasterWidgets.Spike3DRaster.Spike3DRaster at 0x1673e722310>,
                'spike_raster_window': <pyphoplacecellanalysis.GUI.Qt.SpikeRasterWindows.Spike3DRasterWindowWidget.Spike3DRasterWindowWidget at 0x1673e7aaa60>}

            convert_dictionary_to_defn_lines(curr_active_pipeline.last_added_display_output, multiline_assignment_code=False, dictionary_name='curr_active_pipeline.last_added_display_output')
            >>> spike_raster_plt_2d, spike_raster_plt_3d, spike_raster_window = curr_active_pipeline.last_added_display_output['spike_raster_plt_2d'], curr_active_pipeline.last_added_display_output['spike_raster_plt_3d'], curr_active_pipeline.last_added_display_output['spike_raster_window'] # Extract variables from the `curr_active_pipeline.last_added_display_output` dictionary to the local workspace

            active_str = convert_dictionary_to_defn_lines(curr_active_pipeline.last_added_display_output, multiline_assignment_code=True, dictionary_name='curr_active_pipeline.last_added_display_output')
            active_str
            >>> "# Extract variables from the `curr_active_pipeline.last_added_display_output` dictionary to the local workspace\nspike_raster_plt_2d = curr_active_pipeline.last_added_display_output['spike_raster_plt_2d']\nspike_raster_plt_3d = curr_active_pipeline.last_added_display_output['spike_raster_plt_3d']\nspike_raster_window = curr_active_pipeline.last_added_display_output['spike_raster_window']"

            print(active_str)
            >>>
                # Extract variables from the `curr_active_pipeline.last_added_display_output` dictionary to the local workspace
                spike_raster_plt_2d = curr_active_pipeline.last_added_display_output['spike_raster_plt_2d']
                spike_raster_plt_3d = curr_active_pipeline.last_added_display_output['spike_raster_plt_3d']
                spike_raster_window = curr_active_pipeline.last_added_display_output['spike_raster_window']


        Example 2:
            dictionary_definition_string = "{'firing_rate':curr_ax_firing_rate, 'lap_spikes': curr_ax_lap_spikes, 'placefield': curr_ax_placefield}"
            CodeConversion.convert_dictionary_to_defn_lines(dictionary_definition_string, dictionary_name='curr_axs_dict')
            >>>
                firing_rate, lap_spikes, placefield = curr_axs_dict['firing_rate'], curr_axs_dict['lap_spikes'], curr_axs_dict['placefield'] # Extract variables from the `curr_axs_dict` dictionary to the local workspace
        """
        ...
    
    @classmethod
    def convert_dictionary_to_class_defn(cls, target_dict, class_name: str = ..., class_definition_mode: GeneratedClassDefinitionType = ..., copy_to_clipboard=..., output_variable_prefix=..., class_decorators=..., include_init_fcn=..., include_initializer_default_values=..., include_properties_defns=..., include_types=..., use_relative_types=..., indent_character=..., pre_class_spacing=..., post_class_spacing=...): # -> str:
        """ Builds a class definition from a target_dict
            target_dict: either a dictionary object or a string of code that defines a dictionary object (such as "{'firing_rate':curr_ax_firing_rate, 'lap_spikes': curr_ax_lap_spikes, 'placefield': curr_ax_placefield}")
            multiline_assignment_code: if True, generates a separate line for each assignment, otherwise assignment is done inline
            class_name: the name to use for the generated class in the generated code


            include_types: bool - If True, type hints are included in both the properties_defns and init_fcn (if those are enabled, otherwise changes nothing)

            include_properties_defns: if True, includes the properties at the top of the class definintion like is done in an @dataclass
            include_init_fcn: if True, includes a standard __init__(self, ...) function in the definintion




        Examples:
            from pyphocorehelpers.general_helpers import CodeConversion, GeneratedClassDefinitionType
            CodeConversion.convert_dictionary_to_class_defn(_out.to_dict(), class_name='PlacefieldSnapshot', indent_character='    ', include_types=True, class_decorators=None, include_initializer_default_values=False)

            >>>
            class PlacefieldSnapshot(object):
                # Docstring for PlacefieldSnapshot.

                def __init__(self, num_position_samples_occupancy: np.ndarray, seconds_occupancy: np.ndarray, spikes_maps_matrix: np.ndarray, smoothed_spikes_maps_matrix: type, occupancy_weighted_tuning_maps_matrix: np.ndarray):
                    super(PlacefieldSnapshot, self).__init__()        self.num_position_samples_occupancy = num_position_samples_occupancy
                    self.seconds_occupancy = seconds_occupancy
                    self.spikes_maps_matrix = spikes_maps_matrix
                    self.smoothed_spikes_maps_matrix = smoothed_spikes_maps_matrix
                    self.occupancy_weighted_tuning_maps_matrix = occupancy_weighted_tuning_maps_matrix



        """
        ...
    
    @classmethod
    def extract_undefined_variable_names_from_code(cls, code_dict_defn: str, max_iterations_before_abort: int = ..., debug_print=...): # -> list[Any]:
        """ Finds the names of all undefined variables in a given block of code by repetitively replacing it and re-evaluating it. Probably not the smartest doing this.
        Based on `cls.build_dummy_dictionary_from_defn_code(...)`


        Inputs:
            code_dict_defn: lines of code that define several python variables to be converted to dictionary entries
                e.g. code_dict_defn: "{'firing_rate':curr_ax_firing_rate, 'lap_spikes': curr_ax_lap_spikes, 'placefield': curr_ax_placefield}"
        Outputs:
            a dictionary
        """
        ...
    
    @classmethod
    def build_dummy_dictionary_from_defn_code(cls, code_dict_defn: str, max_iterations_before_abort: int = ..., missing_variable_values=..., debug_print=...): # -> Any | dict[Any, Any]:
        """ Consider an inline dictionary definition such as:

            # output the axes created:
            axs_list.append({'firing_rate':curr_ax_firing_rate, 'lap_spikes': curr_ax_lap_spikes, 'placefield': curr_ax_placefield})

        The goal is to be able to extract the members of this dictionary from its returned value, effectively "unwrapping" the dictionary. The problem with just using convert_dictionary_to_defn_lines(...) directly is that you don't have a dictionary, you have a string the defines the dictionary in the original code.
        Attempting to build a dummy dictionary from this code doesn't work, as the variables aren't defined outside of the function that created them.

        One way around this problem is to do the following to define the unbound variables in the dictionary to None:

            curr_ax_firing_rate, curr_ax_lap_spikes, curr_ax_placefield = None, None, None
            CodeConversion.convert_dictionary_to_defn_lines({'firing_rate':curr_ax_firing_rate, 'lap_spikes': curr_ax_lap_spikes, 'placefield': curr_ax_placefield}, dictionary_name='curr_axs_dict')

        This works, but requires extracting the variable names and assigning None for each one. This function automates that process with eval(...)

        >>>
            iteration 0: name 'curr_ax_firing_rate' is not defined
            missing_variable_name: curr_ax_firing_rate
            iteration 1: name 'curr_ax_lap_spikes' is not defined
            missing_variable_name: curr_ax_lap_spikes
            iteration 2: name 'curr_ax_placefield' is not defined
            missing_variable_name: curr_ax_placefield
            Copied "firing_rate, lap_spikes, placefield = target_dict['firing_rate'], target_dict['lap_spikes'], target_dict['placefield'] # Extract variables from the `target_dict` dictionary to the local workspace" to clipboard!

        Inputs:
            code_dict_defn: lines of code that define several python variables to be converted to dictionary entries
                e.g. code_dict_defn: "{'firing_rate':curr_ax_firing_rate, 'lap_spikes': curr_ax_lap_spikes, 'placefield': curr_ax_placefield}"
        Outputs:
            a dictionary
        """
        ...
    
    @classmethod
    def convert_defn_lines_to_dictionary(cls, code, multiline_dict_defn=..., multiline_members_indent=...): # -> LiteralString:
        """ Converts a multiline string containing lines of valid python code definitions into an output string containing a python dictionary definition.

            code: lines of code that define several python variables to be converted to dictionary entries
            multiline_dict_defn: if True, each entry is converted to a new line (multi-line dict defn). Otherwise inline dict defn.

        Implementation: Internally calls cls._convert_defn_line_to_dictionary_line(...) for each line

        Examples:
            test_parameters_defns_code_string = '''
                max_num_spikes_per_neuron = 20000 # the number of spikes to truncate each neuron's timeseries to
                kleinberg_parameters = DynamicParameters(s=2, gamma=0.1)
                use_progress_bar = False # whether to use a tqdm progress bar
                debug_print = False # whether to print debug-level progress using traditional print(...) statements
            '''
            >>> "\nmax_num_spikes_per_neuron = 20000 # the number of spikes to truncate each neuron's timeseries to\nkleinberg_parameters = DynamicParameters(s=2, gamma=0.1)\nuse_progress_bar = False # whether to use a tqdm progress bar\ndebug_print = False # whether to print debug-level progress using traditional print(...) statements\n"

            active_str = CodeConversion.convert_defn_lines_to_dictionary(test_parameters_defns_code_string, multiline_dict_defn=False)
            active_str
            >>> "{'max_num_spikes_per_neuron': 20000, 'kleinberg_parameters': DynamicParameters(s=2, gamma=0.1), 'use_progress_bar': False, 'debug_print': False}"

            print(convert_defn_lines_to_dictionary(test_parameters_defns_code_string, multiline_dict_defn=True))
            >>>
                {
                'max_num_spikes_per_neuron': 20000,
                'kleinberg_parameters': DynamicParameters(s=2, gamma=0.1),
                'use_progress_bar': False,
                'debug_print': False
                }
        """
        ...
    
    @classmethod
    def convert_defn_lines_to_parameters_list(cls, code): # -> LiteralString:
        """
        Inputs:
            code: lines of code that define several python variables to be converted to parameters, as would be passed into a function


        Examples:
            test_parameters_defns_code_string = '''
                max_num_spikes_per_neuron = 20000 # the number of spikes to truncate each neuron's timeseries to
                kleinberg_parameters = DynamicParameters(s=2, gamma=0.1)
                use_progress_bar = False # whether to use a tqdm progress bar
                debug_print = False # whether to print debug-level progress using traditional print(...) statements
            '''

            CodeConversion.convert_defn_lines_to_parameters_list(test_parameters_defns_code_string)
            >>> 'max_num_spikes_per_neuron=20000, kleinberg_parameters=DynamicParameters(s=2, gamma=0.1), use_progress_bar=False, debug_print=False'

        """
        ...
    
    @classmethod
    def convert_variable_tuple_code_to_dict_with_names(cls, tuple_string: str) -> str:
        """ Given a line of code representing a simple tuple or comma separated list of variable names (such as would be returned from a function that returns multiple outputs, or placed on the LHS of a multi-item assignment) returns a transformed line of code representing a dictionary with keys equal to the variable name and value equal to the variable value.

        Example:
            from pyphocorehelpers.general_helpers import CodeConversion

            tuple_string = "(active_filter_epochs, original_1D_decoder, all_included_filter_epochs_decoder_result, flat_all_epochs_measured_cell_spike_counts, flat_all_epochs_measured_cell_firing_rates, flat_all_epochs_decoded_epoch_time_bins, flat_all_epochs_computed_surprises, flat_all_epochs_computed_expected_cell_firing_rates, flat_all_epochs_difference_from_expected_cell_spike_counts, flat_all_epochs_difference_from_expected_cell_firing_rates, all_epochs_decoded_epoch_time_bins_mean, all_epochs_computed_cell_surprises_mean, all_epochs_all_cells_computed_surprises_mean)"
            result_dict_str_rep, result_dict = CodeConversion.convert_variable_tuple_code_to_dict_with_names(tuple_string)
            print(result_dict_str_rep)
            >>> {'active_filter_epochs':active_filter_epochs, 'original_1D_decoder':original_1D_decoder, 'all_included_filter_epochs_decoder_result':all_included_filter_epochs_decoder_result, 'flat_all_epochs_measured_cell_spike_counts':flat_all_epochs_measured_cell_spike_counts, 'flat_all_epochs_measured_cell_firing_rates':flat_all_epochs_measured_cell_firing_rates, 'flat_all_epochs_decoded_epoch_time_bins':flat_all_epochs_decoded_epoch_time_bins, 'flat_all_epochs_computed_surprises':flat_all_epochs_computed_surprises, 'flat_all_epochs_computed_expected_cell_firing_rates':flat_all_epochs_computed_expected_cell_firing_rates, 'flat_all_epochs_difference_from_expected_cell_spike_counts':flat_all_epochs_difference_from_expected_cell_spike_counts, 'flat_all_epochs_difference_from_expected_cell_firing_rates':flat_all_epochs_difference_from_expected_cell_firing_rates, 'all_epochs_decoded_epoch_time_bins_mean':all_epochs_decoded_epoch_time_bins_mean, 'all_epochs_computed_cell_surprises_mean':all_epochs_computed_cell_surprises_mean, 'all_epochs_all_cells_computed_surprises_mean':all_epochs_all_cells_computed_surprises_mean}

        """
        ...
    
    @classmethod
    def get_arguments_as_optional_dict(cls, *args, **kwargs): # -> None:
        """ Easily converts your existing argument-list style default values into a dict:
                Defines a simple function that takes only **kwargs as its inputs and prints the values it recieves. Paste your values as arguments to the function call. The dictionary will be output to the console, so you can easily copy and paste.
            Usage:
                >>> get_arguments_as_optional_dict(point_size=8, font_size=10, name='build_center_labels_test', shape_opacity=0.8, show_points=False)

                Output: ", **({'point_size': 8, 'font_size': 10, 'name': 'build_center_labels_test', 'shape_opacity': 0.8, 'show_points': False} | kwargs)"

            Usage (string-represented kwargs mode):
                Consider in code:
                    `sortby=shared_fragile_neuron_IDXs, included_unit_neuron_IDs=curr_any_context_neurons, fignum=None, ax=ax_long_pf_1D, curve_hatch_style=None`

                We'd like to convert this to an optional dict, which can usually be done by passing it to CodeConversion.get_arguments_as_optional_dict(...) like:
                    `CodeConversion.get_arguments_as_optional_dict(sortby=shared_fragile_neuron_IDXs, included_unit_neuron_IDs=curr_any_context_neurons, fignum=None, ax=ax_long_pf_1D, curve_hatch_style=None)`

                Unfortunately, unless done in the original calling context many of the arguments are undefined, including:
                    shared_fragile_neuron_IDXs, curr_any_context_neurons, ax_long_pf_1D

import pyphocorehelpers.programming_helpers                >>> pyphocorehelpers.programming_helpers.get_arguments_as_optional_dict("sortby=shared_fragile_neuron_IDXs, included_unit_neuron_IDs=curr_any_context_neurons, ax=ax_long_pf_1D", fignum=None, curve_hatch_style=None)

                Output: , **({'fignum': None, 'curve_hatch_style': None, 'sortby': shared_fragile_neuron_IDXs, 'included_unit_neuron_IDs': curr_any_context_neurons, 'ax': ax_long_pf_1D} | kwargs)
        """
        ...
    
    @classmethod
    def generate_unwrap_code_from_dict_like(cls, **kwargs) -> Tuple[str, List[str]]:
        """ Generate unwrapping code from a dict-like class
        Usage:
            from pyphocorehelpers.programming_helpers import CodeConversion

            code_lines_str, code_lines = CodeConversion.generate_unwrap_code_from_dict_like(short_long_pf_overlap_analyses=short_long_pf_overlap_analyses)
            code_lines_str
        

        >> Output:
            ## Unwrapping `short_long_pf_overlap_analyses`:
            short_long_neurons_diff = short_long_pf_overlap_analyses['short_long_neurons_diff']
            poly_overlap_df = short_long_pf_overlap_analyses['poly_overlap_df']
            conv_overlap_dict = short_long_pf_overlap_analyses['conv_overlap_dict']
            conv_overlap_scalars_df = short_long_pf_overlap_analyses['conv_overlap_scalars_df']
            product_overlap_dict = short_long_pf_overlap_analyses['product_overlap_dict']
            product_overlap_scalars_df = short_long_pf_overlap_analyses['product_overlap_scalars_df']
            relative_entropy_overlap_dict = short_long_pf_overlap_analyses['relative_entropy_overlap_dict']
            relative_entropy_overlap_scalars_df = short_long_pf_overlap_analyses['relative_entropy_overlap_scalars_df']


        """
        ...
    


